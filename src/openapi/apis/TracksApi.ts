/* tslint:disable */
/* eslint-disable */
/**
 * Spotify Web API with fixes and improvements from sonallux
 * You can use Spotify\'s Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers.
 *
 * The version of the OpenAPI document: 2025.5.18
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
  AddTracksToPlaylistRequest,
  AudioAnalysisObject,
  AudioFeaturesObject,
  InlineObject,
  InlineObject9,
  InlineObject12,
  InlineObject15,
  PagingPlaylistTrackObject,
  PagingSavedTrackObject,
  PagingSimplifiedTrackObject,
  PagingTrackObject,
  RecommendationsObject,
  RemoveTracksPlaylistRequest,
  ReorderOrReplacePlaylistsTracksRequest,
  SaveAlbumsUserRequest,
  SaveTracksUserRequest,
  TrackObject,
} from "../models/index";
import * as runtime from "../runtime";

export interface TracksApiAddTracksToPlaylistOperationRequest {
  playlistId: string;
  position?: number;
  uris?: string;
  addTracksToPlaylistRequest?: AddTracksToPlaylistRequest;
}

export interface TracksApiCheckUsersSavedTracksRequest {
  ids: string;
}

export interface TracksApiGetAnAlbumsTracksRequest {
  id: string;
  market?: string;
  limit?: number;
  offset?: number;
}

export interface TracksApiGetAnArtistsTopTracksRequest {
  id: string;
  market?: string;
}

export interface TracksApiGetAudioAnalysisRequest {
  id: string;
}

export interface TracksApiGetAudioFeaturesRequest {
  id: string;
}

export interface TracksApiGetPlaylistsTracksRequest {
  playlistId: string;
  market?: string;
  fields?: string;
  limit?: number;
  offset?: number;
  additionalTypes?: string;
}

export interface TracksApiGetRecommendationsRequest {
  limit?: number;
  market?: string;
  seedArtists?: string;
  seedGenres?: string;
  seedTracks?: string;
  minAcousticness?: number;
  maxAcousticness?: number;
  targetAcousticness?: number;
  minDanceability?: number;
  maxDanceability?: number;
  targetDanceability?: number;
  minDurationMs?: number;
  maxDurationMs?: number;
  targetDurationMs?: number;
  minEnergy?: number;
  maxEnergy?: number;
  targetEnergy?: number;
  minInstrumentalness?: number;
  maxInstrumentalness?: number;
  targetInstrumentalness?: number;
  minKey?: number;
  maxKey?: number;
  targetKey?: number;
  minLiveness?: number;
  maxLiveness?: number;
  targetLiveness?: number;
  minLoudness?: number;
  maxLoudness?: number;
  targetLoudness?: number;
  minMode?: number;
  maxMode?: number;
  targetMode?: number;
  minPopularity?: number;
  maxPopularity?: number;
  targetPopularity?: number;
  minSpeechiness?: number;
  maxSpeechiness?: number;
  targetSpeechiness?: number;
  minTempo?: number;
  maxTempo?: number;
  targetTempo?: number;
  minTimeSignature?: number;
  maxTimeSignature?: number;
  targetTimeSignature?: number;
  minValence?: number;
  maxValence?: number;
  targetValence?: number;
}

export interface TracksApiGetSeveralAudioFeaturesRequest {
  ids: string;
}

export interface TracksApiGetSeveralTracksRequest {
  ids: string;
  market?: string;
}

export interface TracksApiGetTrackRequest {
  id: string;
  market?: string;
}

export interface TracksApiGetUsersSavedTracksRequest {
  market?: string;
  limit?: number;
  offset?: number;
}

export interface TracksApiGetUsersTopTracksRequest {
  timeRange?: string;
  limit?: number;
  offset?: number;
}

export interface TracksApiRemoveTracksPlaylistOperationRequest {
  playlistId: string;
  removeTracksPlaylistRequest?: RemoveTracksPlaylistRequest;
}

export interface TracksApiRemoveTracksUserRequest {
  ids: string;
  saveAlbumsUserRequest?: SaveAlbumsUserRequest;
}

export interface TracksApiReorderOrReplacePlaylistsTracksOperationRequest {
  playlistId: string;
  uris?: string;
  reorderOrReplacePlaylistsTracksRequest?: ReorderOrReplacePlaylistsTracksRequest;
}

export interface TracksApiSaveTracksUserOperationRequest {
  ids: string;
  saveTracksUserRequest?: SaveTracksUserRequest;
}

/**
 *
 */
export class TracksApi extends runtime.BaseAPI {
  /**
   * Add one or more items to a user\'s playlist.
   * Add Items to Playlist
   */
  async addTracksToPlaylistRaw(
    requestParameters: TracksApiAddTracksToPlaylistOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<InlineObject15>> {
    if (requestParameters["playlistId"] == null) {
      throw new runtime.RequiredError(
        "playlistId",
        'Required parameter "playlistId" was null or undefined when calling addTracksToPlaylist().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["position"] != null) {
      queryParameters["position"] = requestParameters["position"];
    }

    if (requestParameters["uris"] != null) {
      queryParameters["uris"] = requestParameters["uris"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["playlist-modify-public", "playlist-modify-private"],
      );
    }

    let urlPath = `/playlists/{playlist_id}/tracks`;
    urlPath = urlPath.replace(
      `{${"playlist_id"}}`,
      encodeURIComponent(String(requestParameters["playlistId"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters["addTracksToPlaylistRequest"],
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Add one or more items to a user\'s playlist.
   * Add Items to Playlist
   */
  async addTracksToPlaylist(
    requestParameters: TracksApiAddTracksToPlaylistOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<InlineObject15> {
    const response = await this.addTracksToPlaylistRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Check if one or more tracks is already saved in the current Spotify user\'s \'Your Music\' library.
   * Check User\'s Saved Tracks
   */
  async checkUsersSavedTracksRaw(
    requestParameters: TracksApiCheckUsersSavedTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<boolean>>> {
    if (requestParameters["ids"] == null) {
      throw new runtime.RequiredError(
        "ids",
        'Required parameter "ids" was null or undefined when calling checkUsersSavedTracks().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["ids"] != null) {
      queryParameters["ids"] = requestParameters["ids"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["user-library-read"],
      );
    }

    let urlPath = `/me/tracks/contains`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Check if one or more tracks is already saved in the current Spotify user\'s \'Your Music\' library.
   * Check User\'s Saved Tracks
   */
  async checkUsersSavedTracks(
    requestParameters: TracksApiCheckUsersSavedTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<boolean>> {
    const response = await this.checkUsersSavedTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get Spotify catalog information about an album’s tracks. Optional parameters can be used to limit the number of tracks returned.
   * Get Album Tracks
   */
  async getAnAlbumsTracksRaw(
    requestParameters: TracksApiGetAnAlbumsTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PagingSimplifiedTrackObject>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getAnAlbumsTracks().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/albums/{id}/tracks`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get Spotify catalog information about an album’s tracks. Optional parameters can be used to limit the number of tracks returned.
   * Get Album Tracks
   */
  async getAnAlbumsTracks(
    requestParameters: TracksApiGetAnAlbumsTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PagingSimplifiedTrackObject> {
    const response = await this.getAnAlbumsTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get Spotify catalog information about an artist\'s top tracks by country.
   * Get Artist\'s Top Tracks
   */
  async getAnArtistsTopTracksRaw(
    requestParameters: TracksApiGetAnArtistsTopTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<InlineObject12>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getAnArtistsTopTracks().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/artists/{id}/top-tracks`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get Spotify catalog information about an artist\'s top tracks by country.
   * Get Artist\'s Top Tracks
   */
  async getAnArtistsTopTracks(
    requestParameters: TracksApiGetAnArtistsTopTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<InlineObject12> {
    const response = await this.getAnArtistsTopTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track’s structure and musical content, including rhythm, pitch, and timbre.
   * Get Track\'s Audio Analysis
   * @deprecated
   */
  async getAudioAnalysisRaw(
    requestParameters: TracksApiGetAudioAnalysisRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AudioAnalysisObject>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getAudioAnalysis().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/audio-analysis/{id}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track’s structure and musical content, including rhythm, pitch, and timbre.
   * Get Track\'s Audio Analysis
   * @deprecated
   */
  async getAudioAnalysis(
    requestParameters: TracksApiGetAudioAnalysisRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AudioAnalysisObject> {
    const response = await this.getAudioAnalysisRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get audio feature information for a single track identified by its unique Spotify ID.
   * Get Track\'s Audio Features
   * @deprecated
   */
  async getAudioFeaturesRaw(
    requestParameters: TracksApiGetAudioFeaturesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AudioFeaturesObject>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getAudioFeatures().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/audio-features/{id}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get audio feature information for a single track identified by its unique Spotify ID.
   * Get Track\'s Audio Features
   * @deprecated
   */
  async getAudioFeatures(
    requestParameters: TracksApiGetAudioFeaturesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AudioFeaturesObject> {
    const response = await this.getAudioFeaturesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get full details of the items of a playlist owned by a Spotify user.
   * Get Playlist Items
   */
  async getPlaylistsTracksRaw(
    requestParameters: TracksApiGetPlaylistsTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PagingPlaylistTrackObject>> {
    if (requestParameters["playlistId"] == null) {
      throw new runtime.RequiredError(
        "playlistId",
        'Required parameter "playlistId" was null or undefined when calling getPlaylistsTracks().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    if (requestParameters["fields"] != null) {
      queryParameters["fields"] = requestParameters["fields"];
    }

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    if (requestParameters["additionalTypes"] != null) {
      queryParameters["additional_types"] =
        requestParameters["additionalTypes"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["playlist-read-private"],
      );
    }

    let urlPath = `/playlists/{playlist_id}/tracks`;
    urlPath = urlPath.replace(
      `{${"playlist_id"}}`,
      encodeURIComponent(String(requestParameters["playlistId"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get full details of the items of a playlist owned by a Spotify user.
   * Get Playlist Items
   */
  async getPlaylistsTracks(
    requestParameters: TracksApiGetPlaylistsTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PagingPlaylistTrackObject> {
    const response = await this.getPlaylistsTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.  For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks.
   * Get Recommendations
   * @deprecated
   */
  async getRecommendationsRaw(
    requestParameters: TracksApiGetRecommendationsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<RecommendationsObject>> {
    const queryParameters: any = {};

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    if (requestParameters["seedArtists"] != null) {
      queryParameters["seed_artists"] = requestParameters["seedArtists"];
    }

    if (requestParameters["seedGenres"] != null) {
      queryParameters["seed_genres"] = requestParameters["seedGenres"];
    }

    if (requestParameters["seedTracks"] != null) {
      queryParameters["seed_tracks"] = requestParameters["seedTracks"];
    }

    if (requestParameters["minAcousticness"] != null) {
      queryParameters["min_acousticness"] =
        requestParameters["minAcousticness"];
    }

    if (requestParameters["maxAcousticness"] != null) {
      queryParameters["max_acousticness"] =
        requestParameters["maxAcousticness"];
    }

    if (requestParameters["targetAcousticness"] != null) {
      queryParameters["target_acousticness"] =
        requestParameters["targetAcousticness"];
    }

    if (requestParameters["minDanceability"] != null) {
      queryParameters["min_danceability"] =
        requestParameters["minDanceability"];
    }

    if (requestParameters["maxDanceability"] != null) {
      queryParameters["max_danceability"] =
        requestParameters["maxDanceability"];
    }

    if (requestParameters["targetDanceability"] != null) {
      queryParameters["target_danceability"] =
        requestParameters["targetDanceability"];
    }

    if (requestParameters["minDurationMs"] != null) {
      queryParameters["min_duration_ms"] = requestParameters["minDurationMs"];
    }

    if (requestParameters["maxDurationMs"] != null) {
      queryParameters["max_duration_ms"] = requestParameters["maxDurationMs"];
    }

    if (requestParameters["targetDurationMs"] != null) {
      queryParameters["target_duration_ms"] =
        requestParameters["targetDurationMs"];
    }

    if (requestParameters["minEnergy"] != null) {
      queryParameters["min_energy"] = requestParameters["minEnergy"];
    }

    if (requestParameters["maxEnergy"] != null) {
      queryParameters["max_energy"] = requestParameters["maxEnergy"];
    }

    if (requestParameters["targetEnergy"] != null) {
      queryParameters["target_energy"] = requestParameters["targetEnergy"];
    }

    if (requestParameters["minInstrumentalness"] != null) {
      queryParameters["min_instrumentalness"] =
        requestParameters["minInstrumentalness"];
    }

    if (requestParameters["maxInstrumentalness"] != null) {
      queryParameters["max_instrumentalness"] =
        requestParameters["maxInstrumentalness"];
    }

    if (requestParameters["targetInstrumentalness"] != null) {
      queryParameters["target_instrumentalness"] =
        requestParameters["targetInstrumentalness"];
    }

    if (requestParameters["minKey"] != null) {
      queryParameters["min_key"] = requestParameters["minKey"];
    }

    if (requestParameters["maxKey"] != null) {
      queryParameters["max_key"] = requestParameters["maxKey"];
    }

    if (requestParameters["targetKey"] != null) {
      queryParameters["target_key"] = requestParameters["targetKey"];
    }

    if (requestParameters["minLiveness"] != null) {
      queryParameters["min_liveness"] = requestParameters["minLiveness"];
    }

    if (requestParameters["maxLiveness"] != null) {
      queryParameters["max_liveness"] = requestParameters["maxLiveness"];
    }

    if (requestParameters["targetLiveness"] != null) {
      queryParameters["target_liveness"] = requestParameters["targetLiveness"];
    }

    if (requestParameters["minLoudness"] != null) {
      queryParameters["min_loudness"] = requestParameters["minLoudness"];
    }

    if (requestParameters["maxLoudness"] != null) {
      queryParameters["max_loudness"] = requestParameters["maxLoudness"];
    }

    if (requestParameters["targetLoudness"] != null) {
      queryParameters["target_loudness"] = requestParameters["targetLoudness"];
    }

    if (requestParameters["minMode"] != null) {
      queryParameters["min_mode"] = requestParameters["minMode"];
    }

    if (requestParameters["maxMode"] != null) {
      queryParameters["max_mode"] = requestParameters["maxMode"];
    }

    if (requestParameters["targetMode"] != null) {
      queryParameters["target_mode"] = requestParameters["targetMode"];
    }

    if (requestParameters["minPopularity"] != null) {
      queryParameters["min_popularity"] = requestParameters["minPopularity"];
    }

    if (requestParameters["maxPopularity"] != null) {
      queryParameters["max_popularity"] = requestParameters["maxPopularity"];
    }

    if (requestParameters["targetPopularity"] != null) {
      queryParameters["target_popularity"] =
        requestParameters["targetPopularity"];
    }

    if (requestParameters["minSpeechiness"] != null) {
      queryParameters["min_speechiness"] = requestParameters["minSpeechiness"];
    }

    if (requestParameters["maxSpeechiness"] != null) {
      queryParameters["max_speechiness"] = requestParameters["maxSpeechiness"];
    }

    if (requestParameters["targetSpeechiness"] != null) {
      queryParameters["target_speechiness"] =
        requestParameters["targetSpeechiness"];
    }

    if (requestParameters["minTempo"] != null) {
      queryParameters["min_tempo"] = requestParameters["minTempo"];
    }

    if (requestParameters["maxTempo"] != null) {
      queryParameters["max_tempo"] = requestParameters["maxTempo"];
    }

    if (requestParameters["targetTempo"] != null) {
      queryParameters["target_tempo"] = requestParameters["targetTempo"];
    }

    if (requestParameters["minTimeSignature"] != null) {
      queryParameters["min_time_signature"] =
        requestParameters["minTimeSignature"];
    }

    if (requestParameters["maxTimeSignature"] != null) {
      queryParameters["max_time_signature"] =
        requestParameters["maxTimeSignature"];
    }

    if (requestParameters["targetTimeSignature"] != null) {
      queryParameters["target_time_signature"] =
        requestParameters["targetTimeSignature"];
    }

    if (requestParameters["minValence"] != null) {
      queryParameters["min_valence"] = requestParameters["minValence"];
    }

    if (requestParameters["maxValence"] != null) {
      queryParameters["max_valence"] = requestParameters["maxValence"];
    }

    if (requestParameters["targetValence"] != null) {
      queryParameters["target_valence"] = requestParameters["targetValence"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/recommendations`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.  For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks.
   * Get Recommendations
   * @deprecated
   */
  async getRecommendations(
    requestParameters: TracksApiGetRecommendationsRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<RecommendationsObject> {
    const response = await this.getRecommendationsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get audio features for multiple tracks based on their Spotify IDs.
   * Get Several Tracks\' Audio Features
   * @deprecated
   */
  async getSeveralAudioFeaturesRaw(
    requestParameters: TracksApiGetSeveralAudioFeaturesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<InlineObject9>> {
    if (requestParameters["ids"] == null) {
      throw new runtime.RequiredError(
        "ids",
        'Required parameter "ids" was null or undefined when calling getSeveralAudioFeatures().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["ids"] != null) {
      queryParameters["ids"] = requestParameters["ids"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/audio-features`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get audio features for multiple tracks based on their Spotify IDs.
   * Get Several Tracks\' Audio Features
   * @deprecated
   */
  async getSeveralAudioFeatures(
    requestParameters: TracksApiGetSeveralAudioFeaturesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<InlineObject9> {
    const response = await this.getSeveralAudioFeaturesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get Spotify catalog information for multiple tracks based on their Spotify IDs.
   * Get Several Tracks
   */
  async getSeveralTracksRaw(
    requestParameters: TracksApiGetSeveralTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<InlineObject12>> {
    if (requestParameters["ids"] == null) {
      throw new runtime.RequiredError(
        "ids",
        'Required parameter "ids" was null or undefined when calling getSeveralTracks().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    if (requestParameters["ids"] != null) {
      queryParameters["ids"] = requestParameters["ids"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/tracks`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get Spotify catalog information for multiple tracks based on their Spotify IDs.
   * Get Several Tracks
   */
  async getSeveralTracks(
    requestParameters: TracksApiGetSeveralTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<InlineObject12> {
    const response = await this.getSeveralTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get Spotify catalog information for a single track identified by its unique Spotify ID.
   * Get Track
   */
  async getTrackRaw(
    requestParameters: TracksApiGetTrackRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<TrackObject>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getTrack().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        [],
      );
    }

    let urlPath = `/tracks/{id}`;
    urlPath = urlPath.replace(
      `{${"id"}}`,
      encodeURIComponent(String(requestParameters["id"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get Spotify catalog information for a single track identified by its unique Spotify ID.
   * Get Track
   */
  async getTrack(
    requestParameters: TracksApiGetTrackRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<TrackObject> {
    const response = await this.getTrackRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get a list of the songs saved in the current Spotify user\'s \'Your Music\' library.
   * Get User\'s Saved Tracks
   */
  async getUsersSavedTracksRaw(
    requestParameters: TracksApiGetUsersSavedTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PagingSavedTrackObject>> {
    const queryParameters: any = {};

    if (requestParameters["market"] != null) {
      queryParameters["market"] = requestParameters["market"];
    }

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["user-library-read"],
      );
    }

    let urlPath = `/me/tracks`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get a list of the songs saved in the current Spotify user\'s \'Your Music\' library.
   * Get User\'s Saved Tracks
   */
  async getUsersSavedTracks(
    requestParameters: TracksApiGetUsersSavedTracksRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PagingSavedTrackObject> {
    const response = await this.getUsersSavedTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get the current user\'s top tracks based on calculated affinity.
   * Get User\'s Top Tracks
   */
  async getUsersTopTracksRaw(
    requestParameters: TracksApiGetUsersTopTracksRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PagingTrackObject>> {
    const queryParameters: any = {};

    if (requestParameters["timeRange"] != null) {
      queryParameters["time_range"] = requestParameters["timeRange"];
    }

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["user-top-read"],
      );
    }

    let urlPath = `/me/top/tracks`;

    const response = await this.request(
      {
        path: urlPath,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get the current user\'s top tracks based on calculated affinity.
   * Get User\'s Top Tracks
   */
  async getUsersTopTracks(
    requestParameters: TracksApiGetUsersTopTracksRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PagingTrackObject> {
    const response = await this.getUsersTopTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Remove one or more items from a user\'s playlist.
   * Remove Playlist Items
   */
  async removeTracksPlaylistRaw(
    requestParameters: TracksApiRemoveTracksPlaylistOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<InlineObject15>> {
    if (requestParameters["playlistId"] == null) {
      throw new runtime.RequiredError(
        "playlistId",
        'Required parameter "playlistId" was null or undefined when calling removeTracksPlaylist().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["playlist-modify-public", "playlist-modify-private"],
      );
    }

    let urlPath = `/playlists/{playlist_id}/tracks`;
    urlPath = urlPath.replace(
      `{${"playlist_id"}}`,
      encodeURIComponent(String(requestParameters["playlistId"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters["removeTracksPlaylistRequest"],
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Remove one or more items from a user\'s playlist.
   * Remove Playlist Items
   */
  async removeTracksPlaylist(
    requestParameters: TracksApiRemoveTracksPlaylistOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<InlineObject15> {
    const response = await this.removeTracksPlaylistRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Remove one or more tracks from the current user\'s \'Your Music\' library.
   * Remove User\'s Saved Tracks
   */
  async removeTracksUserRaw(
    requestParameters: TracksApiRemoveTracksUserRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["ids"] == null) {
      throw new runtime.RequiredError(
        "ids",
        'Required parameter "ids" was null or undefined when calling removeTracksUser().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["ids"] != null) {
      queryParameters["ids"] = requestParameters["ids"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["user-library-modify"],
      );
    }

    let urlPath = `/me/tracks`;

    const response = await this.request(
      {
        path: urlPath,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters["saveAlbumsUserRequest"],
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Remove one or more tracks from the current user\'s \'Your Music\' library.
   * Remove User\'s Saved Tracks
   */
  async removeTracksUser(
    requestParameters: TracksApiRemoveTracksUserRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.removeTracksUserRaw(requestParameters, initOverrides);
  }

  /**
   * Either reorder or replace items in a playlist depending on the request\'s parameters. To reorder items, include `range_start`, `insert_before`, `range_length` and `snapshot_id` in the request\'s body. To replace items, include `uris` as either a query parameter or in the request\'s body. Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist. <br/> **Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters. These operations can\'t be applied together in a single request.
   * Update Playlist Items
   */
  async reorderOrReplacePlaylistsTracksRaw(
    requestParameters: TracksApiReorderOrReplacePlaylistsTracksOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<InlineObject15>> {
    if (requestParameters["playlistId"] == null) {
      throw new runtime.RequiredError(
        "playlistId",
        'Required parameter "playlistId" was null or undefined when calling reorderOrReplacePlaylistsTracks().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["uris"] != null) {
      queryParameters["uris"] = requestParameters["uris"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["playlist-modify-public", "playlist-modify-private"],
      );
    }

    let urlPath = `/playlists/{playlist_id}/tracks`;
    urlPath = urlPath.replace(
      `{${"playlist_id"}}`,
      encodeURIComponent(String(requestParameters["playlistId"])),
    );

    const response = await this.request(
      {
        path: urlPath,
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters["reorderOrReplacePlaylistsTracksRequest"],
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Either reorder or replace items in a playlist depending on the request\'s parameters. To reorder items, include `range_start`, `insert_before`, `range_length` and `snapshot_id` in the request\'s body. To replace items, include `uris` as either a query parameter or in the request\'s body. Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist. <br/> **Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters. These operations can\'t be applied together in a single request.
   * Update Playlist Items
   */
  async reorderOrReplacePlaylistsTracks(
    requestParameters: TracksApiReorderOrReplacePlaylistsTracksOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<InlineObject15> {
    const response = await this.reorderOrReplacePlaylistsTracksRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Save one or more tracks to the current user\'s \'Your Music\' library.
   * Save Tracks for Current User
   */
  async saveTracksUserRaw(
    requestParameters: TracksApiSaveTracksUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["ids"] == null) {
      throw new runtime.RequiredError(
        "ids",
        'Required parameter "ids" was null or undefined when calling saveTracksUser().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["ids"] != null) {
      queryParameters["ids"] = requestParameters["ids"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "oauth_2_0",
        ["user-library-modify"],
      );
    }

    let urlPath = `/me/tracks`;

    const response = await this.request(
      {
        path: urlPath,
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters["saveTracksUserRequest"],
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Save one or more tracks to the current user\'s \'Your Music\' library.
   * Save Tracks for Current User
   */
  async saveTracksUser(
    requestParameters: TracksApiSaveTracksUserOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.saveTracksUserRaw(requestParameters, initOverrides);
  }
}
